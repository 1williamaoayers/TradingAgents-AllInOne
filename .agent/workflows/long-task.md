# 超长任务处理流程

## 触发条件
当我预估任务执行时间 > 3 分钟时，自动触发此流程

---

## 核心原则
**永远不要让单次执行超过 3 分钟**（后端可能随时断连，不给你反应机会）

---

## 执行前强制自检

```
预估时间 > 3分钟？
  → YES: 立即拆解，拒绝直接执行
  → NO: 正常执行
```

---

## 拆解流程

### 步骤1：预防性拆解（开始前）
- 看到任务立即评估："这会超过 3 分钟吗？"
- 如果会，**立即停止**，先输出拆解方案
- 格式："这个任务我会分 X 步完成，每步约 Y 分钟"
- 等用户确认后再开始第一步

### 步骤2：强制分段执行
- 每个子任务严格控制在 **2-3 分钟**内
- 避免：一次读取 10+ 文件、大循环、深度递归
- 使用：批量操作分批次、大文件分段读取

### 步骤3：检查点持久化
- 每完成一步立即写入 `notes.md`："✓ 步骤 X/总数 完成"
- 关键数据存文件，不依赖内存/上下文
- 断线后用户说"继续"，从 `notes.md` 恢复

### 步骤4：主动中断刷新
- 每 2-3 分钟主动停下来问："继续下一步？"
- 强制刷新会话，重置后端超时计时器
- 给用户喘息机会，也给自己续命机会

### 步骤5：紧急降级
- 如果发现操作变慢（工具调用延迟增加）
- 立即暂停，输出："已完成 X，为防断线暂停，回复'继续'执行下一步"

---

## 禁止行为
- ❌ "这个任务很快，我一次性做完" → 可能卡死
- ❌ 连续调用 10+ 次工具不停顿 → 后端会断你
- ❌ 依赖内存记住中间结果 → 断线后全丢

---

## 正确示范

### 示例1：实现完整功能
```
用户："实现完整的用户系统"

我："这个任务我会分 5 步：
  1. 数据库模型 (2分钟)
  2. API接口 (3分钟)  
  3. 前端页面 (3分钟)
  4. 权限验证 (2分钟)
  5. 测试验证 (2分钟)
现在开始第 1 步？"
```

### 示例2：分析大量文件
```
用户："分析所有 API 文件找出性能问题"

我："这个项目有 15 个 API 文件，我会分 3 批分析：
  批次1: 分析 5 个核心 API (3分钟)
  批次2: 分析 5 个次要 API (3分钟)
  批次3: 分析剩余 5 个 + 总结 (3分钟)
现在开始批次 1？"
```

---

## 时间估算参考

| 操作类型 | 预估时间 |
|---------|---------|
| 读取 1-2 个文件 | < 1 分钟 |
| 读取 3-5 个文件 | 1-2 分钟 |
| 修改 1-2 个文件 | 1-2 分钟 |
| 运行测试 | 1-3 分钟 |
| 复杂分析 | 2-3 分钟 |
| Git 提交推送 | 1-2 分钟 |

**如果多个操作组合 > 3 分钟，必须拆解！**
